#!/usr/bin/env ruby
# frozen_string_literal: true
#
# raspp - Assembly Preprocessor in Ruby
# Copyright (C) 2019 Jeffrey Sharp
#
# raspp is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# raspp is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
# the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with raspp.  If not, see <http://www.gnu.org/licenses/>.
#

module Raspp

  # An even more basic object
  class CleanObject < BasicObject
    # public  methods: __send__, __eval__, __exec__, __id__
    # private methods: initialize, method_missing, singleton_method_added,
    #                  singleton_method_removed, singleton_method_undefined

    define_method :__send__, ::Object.instance_method(:public_send)
    define_method :__eval__,          instance_method(:instance_eval)
    define_method :__exec__,          instance_method(:instance_exec)

    undef_method :!, :!=, :==, :equal?, :instance_eval, :instance_exec

    freeze
  end

  # A proxy to sandbox DSL code so it cannot damage its contexts
  class Sandbox < CleanObject
    undef_method :__id__
    private

    def initialize(context)
      raise "required: context" unless CleanObject === context
      @__context__ = context
    end

    def method_missing(name, *args, &block)
      # Redirect all invocations to internal context.
      @__context__.__send__(name, *args, &block)
    end

    def respond_to_missing?(name, all)
      # Redirect all invocations to internal context.
      @__context__.respond_to?(name, false)
    end

    def self.const_missing(name)
      # Make 'uninitialized constant' errors prettier.
      ::Object.const_get(name)
    end

    freeze
  end

  # Base class for contexts in which DSL code exexutes
  class Context < CleanObject
    def __eval__(ruby, path="-", line=1)
      case ruby
      when ::Proc then Sandbox.new(self).__eval__(&ruby)
      else             Sandbox.new(self).__eval__(ruby, path, line)
      end
    end

    def print *msgs
      loc = source_location
      $stderr.puts *msgs.map { |msg| "#{loc}: #{msg}" }
    end

    def error *msgs
      print *msgs
      msg = case msgs.count
            when 0 then "unspecified error"
            when 1 then msgs[0]
            when 2 then "multiple errors"
            end
      ::Kernel.raise Error, msg
    end

    protected

    def source_location
      locations = ($!)&.backtrace_locations || ::Kernel.caller_locations
      locations
         .find { |loc| loc.path != __FILE__ }
        &.then { |loc| "#{loc.path}:#{loc.lineno}" }
    end
  end

  class CodeContext < Context
    def initialize
      @out = ::String.new(capacity: 4096)
    end
  end

  # The top-level context
  class TopLevel < CodeContext
    def __eval__(ruby, path="-", line=1)
      super
      $stdout << @out
    rescue Error => e
      print e
      ::Kernel.raise
    end
  end

  class Error < RuntimeError
  end
end

# Script main
if __FILE__ == $0
  until ARGV.empty?
    begin
      Raspp::TopLevel
        .new
        .__eval__(ARGF.file.read, ARGF.path)
    rescue Raspp::Error
      exit false
    end
    ARGF.skip
  end
end

